![](https://i.imgur.com/5xjT6Zu.png)

<article class="main-page-content" lang="ru"><h1>CSS-селекторы</h1><div><div id="sect1"></div>

<p><strong>Селектор </strong>определяет, к какому элементу применять то или иное CSS-правило.</p>

<p>Обратите внимание - не существует селекторов, которые бы позволили выбрать родителя (содержащий контейнер) или соседа родителя или потомков соседа родителя.</p></div><h2 id="базовые_селекторы"><a href="#базовые_селекторы" title="Permalink to Базовые селекторы">Базовые селекторы</a></h2><div><dl>
 <dt id="универсальный_селектор"><a href="#универсальный_селектор">Универсальный селектор</a></dt>
 <dd>Выбирает все элементы. По желанию, он может быть ограничен определённым пространством имён или относиться ко всему пространству имён.<br>
 <strong>Синтаксис:</strong> <code>*</code> <code><var>ns</var>|*</code> <code>*|*</code><br>
 <strong>Пример:</strong> <code>*</code> будет соответствовать всем элементам на странице.</dd>
</dl>

<dl>
 <dt id="селекторы_по_типу_элемента"><a href="#селекторы_по_типу_элемента">Селекторы по типу элемента</a></dt>
 <dd>Этот базовый селектор выбирает тип элементов, к которым&nbsp;будет&nbsp;применяться правило.<br>
 <strong>Синтаксис: </strong> <code><var>элемент</var></code><br>
 <strong>Пример: </strong>селектор<strong>&nbsp;</strong><code>input</code> выберет все элементы&nbsp;<code>&lt;input&gt;</code>.</dd>
 <dt id="селекторы_по_классу"><a href="#селекторы_по_классу">Селекторы по классу</a></dt>
 <dd>Этот базовый селектор выбирает элементы, основываясь на значении их атрибута&nbsp;<code>class</code>.<br>
 <strong>Синтаксис: </strong> <code>.<em>имяКласса</em></code><br>
 <strong>Пример: </strong>селектор<strong>&nbsp;</strong><code>.index</code>&nbsp;выберет все элементы с соответствующим&nbsp;классом (который был определён в атрибуте <code>class="index"</code>).</dd>
 <dt id="селекторы_по_идентификатору"><a href="#селекторы_по_идентификатору">Селекторы по&nbsp;идентификатору</a></dt>
 <dd>Этот базовый селектор выбирает элементы, основываясь на значении их <code>id</code>&nbsp;атрибута. Не забывайте, что идентификатор&nbsp;должен быть уникальным, т. е. использоваться только для одного элемента в HTML-документе.&nbsp;<br>
 <strong>Синтаксис: </strong> <code>#имяИдентификатора</code><br>
 <strong>Пример: </strong>селектор&nbsp;<code>#toc</code>&nbsp;выберет элемент с идентификатором&nbsp;toc (который был определён в атрибуте <code>id="toc"</code>).</dd>
 <dt id="селекторы_по_атрибуту"><a href="#селекторы_по_атрибуту">Селекторы по атрибуту</a></dt>
 <dd>Этот селектор выбирает все элементы, имеющие данный атрибут или атрибут с определённым значением.<br>
 <strong>Синтаксис:</strong> <code>[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]</code><br>
 <strong>Пример: </strong>селектор <code>[autoplay]</code>&nbsp;выберет все элементы, у которых есть&nbsp; атрибут <code>autoplay</code>&nbsp;(независимо от его значения).<br>

<strong>На атрибут целиком:</strong>

<code>[attr]</code> – атрибут установлен,
<code>[attr="val"]</code> – атрибут равен val.<br>

<strong>На начало атрибута:</strong>

<code>[attr^="val"]</code> – атрибут начинается с <code>val</code>, например <code>"value"</code>.
<code>[attr|="val"]</code> – атрибут равен <code>val</code> или начинается с <code>val-</code>, например равен <code>"val-1"</code>.<br>

<strong>На содержание:</strong>

<code>[attr*="val"]</code> – атрибут содержит подстроку val, например равен "myvalue".
<code>[attr~="val"]</code> – атрибут содержит val как одно из значений через пробел.
Например: <code>[attr~="delete"]</code> верно для "edit delete" и неверно для "undelete" или "no-delete".<br>

<strong>На конец атрибута:</strong>

<code>[attr$="val"]</code> – атрибут заканчивается на val, например равен <code>"myval"</code>.</dd>

</dl></div>

<h2 id="отношения"><a href="#отношения" title="Permalink to Отношения">Отношения</a></h2><div><dl>
 <dt id="по_месту_соседей"><a href="#по_месту_соседей">Фильтр по месту среди соседей</a></dt>
 <dd><p>При выборе элемента можно указать его место среди соседей.</p>
<p>Список псевдоклассов для этого:</p>
<ul>
<li>
<p><code>:first-child</code> – первый потомок своего родителя.</p>
</li>
<li>
<p><code>:last-child</code> – последний потомок своего родителя.</p>
</li>
<li>
<p><code>:only-child</code> – единственный потомок своего родителя, соседних элементов нет.</p>
</li>
<li>
<p><code>:nth-child(a)</code> – потомок номер <code>a</code> своего родителя, например <code>:nth-child(2)</code> – второй потомок. Нумерация начинается с <code>1</code>.</p>
</li>
<li>
<p><code>:nth-child(an+b)</code> – расширение предыдущего селектора через указание номера потомка формулой, где <code>a,b</code> – константы, а под <code>n</code> подразумевается любое целое число.</p>
<p>Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо <code>n</code>. Например:
-<code>:nth-child(2n)</code> даст элементы номер <code>2</code>, <code>4</code>, <code>6</code>…, то есть чётные.</p>
<ul>
<li><code>:nth-child(2n+1)</code> даст элементы номер <code>1</code>, <code>3</code>…, то есть нечётные.</li>
<li><code>:nth-child(3n+2)</code> даст элементы номер <code>2</code>, <code>5</code>, <code>8</code> и так далее.</li>
</ul>
</li>
</ul><br></dd>

<dt id="по_месту_соседей_с_тегом"><a href="#по_месту_соседей_с_тегом">Фильтр по месту среди соседей с тем же тегом</a></dt>
 <dd>
 <p>Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:</p>
<ul>
<li><code>:first-of-type</code></li>
<li><code>:last-of-type</code></li>
<li><code>:only-of-type</code></li>
<li><code>:nth-of-type</code></li>
<li><code>:nth-last-of-type</code></li>
</ul>
<p>Они имеют в точности тот же смысл, что и обычные <code>:first-child</code>, <code>:last-child</code> и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.</p>
 <br></dd>
</dl></div>

<h2 id="комбинаторы"><a href="#комбинаторы" title="Permalink to Комбинаторы">Комбинаторы</a></h2><div><dl>
 <dt id="комбинатор_запятая"><a href="#комбинатор_запятая">Комбинатор запятая</a></dt>
 <dd>Комбинатор <code>,</code> это способ группировки, он выбирает все совпадающие узлы.<br>
 <strong>Синтаксис:</strong> <code style="white-space: nowrap;"><var>A</var>, <var>B</var></code><br>
 <strong>Пример:</strong> <code>div, span</code> выберет оба элемента - и <code>&lt;div&gt;</code> и <code>&lt;span&gt;</code>.</dd>
 <dt id="комбинатор_потомков"><a href="#комбинатор_потомков">Комбинатор потомков</a></dt>
 <dd>Комбинатор <code>' '</code> (пробел) выбирает элементы, которые находятся внутри указанного элемента (вне зависимости от уровня вложенности).<br>
 <strong>Синтаксис:</strong> <code>A B</code><br>
 <strong>Пример: </strong>селектор <code>div span</code>&nbsp;выберет все элементы <code>&lt;span&gt;</code>, которые находятся внутри элемента <code>&lt;div&gt;</code>.</dd>
 <dt id="дочерние_селекторы"><a href="#дочерние_селекторы">Дочерние&nbsp;селекторы</a></dt>
 <dd>Комбинатор&nbsp;<code>'&gt;'</code> в отличие от пробела выбирает только те элементы, которые являются дочерними непосредственно по отношению к указанному элементу.<br>
 <strong>Синтаксис:</strong> <code><var>A</var> &gt; <var>B</var></code><br>
 <strong>Пример: </strong>селектор<strong>&nbsp;</strong><code>ul &gt; li</code>&nbsp;выберет только дочерние элементы <code>&lt;li&gt;</code>, которые находятся внутри, на первом уровне вложенности по отношению к элементу <code>&lt;ul&gt;</code>.</dd>
 <dt id="комбинатор_всех_соседних_элементов"><a href="#комбинатор_всех_соседних_элементов">Комбинатор всех соседних элементов</a></dt>
 <dd>Комбинатор <code>'~'</code>&nbsp;выбирает элементы, которые находятся на этом же уровне вложенности, после указанного элемента, с тем же родителем.<br>
 <strong>Синтаксис:</strong>&nbsp;<code><var>A</var> ~ <var>B</var></code><br>
 <strong>Пример:</strong> <code>p ~ span</code>&nbsp;выберет все элементы <code>&lt;span&gt;</code>, которые находятся после элемента <code>&lt;p&gt;</code> внутри одного родителя.</dd>
 <dt id="комбинатор_следующего_соседнего_элемента"><a href="#комбинатор_следующего_соседнего_элемента">Комбинатор следующего соседнего элемента</a></dt>
 <dd>Комбинатор <code>'+'</code>&nbsp;выбирает элемент, который&nbsp;находится непосредственно после указанного элемента, если у них общий родитель.<br>
 <strong>Синтаксис:</strong> <code><var>A</var> + <var>B</var></code><br>
 <strong>Пример: </strong>селектор&nbsp;<code>ul + li</code> выберет любой <code>&lt;li&gt;</code> элемент, который &nbsp;находится непосредственно после элемента <code>&lt;ul&gt;</code>.</dd>
</dl></div><h2 id="псевдо"><a href="#псевдо" title="Permalink to Псевдо">Псевдо</a></h2><div><dl>
 <dt id="псевдоклассы"><a href="#псевдоклассы">Псевдоклассы</a></dt>
 <dd>Знак <code>:</code> позволяет выбрать элементы, основываясь на информации, которой нет в дереве элементов.<br>
 <strong>Пример: </strong><code>a:visited</code> соответствует всем элементам <code>&lt;a&gt;</code> которые имеют статус "посещённые".<br>
 <strong>Ещё пример</strong>: <code>div:hover</code> соответствует элементу, над которым проходит указатель мыши.<br>
 <strong>Ещё пример</strong>: <code>input:focus</code> соответствует полю ввода, которое получило фокус.</dd>
 <dt id="другие_псевдоклассы"><a href="#другие_псевдоклассы">Другие псевдоклассы</a></dt>
 <dd>
<ul>
<li>
<p><code>:not(селектор)</code> – все, кроме подходящих под селектор.</p>
</li>
<li>
<p><code>:focus</code> – в фокусе.</p>
</li>
<li>
<p><code>:hover</code> – под мышью.</p>
</li>
<li>
<p><code>:empty</code> – без детей (даже без текстовых).</p>
</li>
<li>
<p><code>:checked</code>, <code>:disabled</code>, <code>:enabled</code> – состояния <code>INPUT</code>.</p>
</li>
<li>
<p><code>:target</code> – этот фильтр сработает для элемента, <code>ID</code> которого совпадает с анкором  <code>#...</code> текущего URL.</p>
<p>Например, если на странице есть элемент с <code>id="intro"</code>, то правило <code>:target { color: red }</code> подсветит его в том случае, если текущий URL имеет вид <code>http://...#intro</code>.</p>
</li>
</ul></dd>

 <dt id="псевдоэлементы"><a href="#псевдоэлементы">Псевдоэлементы</a></dt>
 <dd>Знак <code>::</code> позволяет выбрать вещи, которых нет в HTML.<br>
 <strong>Пример:</strong> <code>p::first-line</code> соответствует первой линии абзаца <code>&lt;p&gt;</code>.</dd>

  <dt id="другие_псевдоэлементы"><a href="#другие_псевдоэлементы">Другие псевдоэлементы</a></dt>
 <dd>
<p>«Псевдоэлементы» – различные вспомогательные элементы, которые браузер записывает или может записать в документ.</p>
<p>При помощи <em>псевдоэлементов</em> <code>::before</code> и <code>::after</code> можно добавлять содержимое в начало и конец элемента:</p></dd>
</dl></div></article>